package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"net/http"
	"time"

	"github.com/khalidibnwalid/sadaa/server/internal/db"
	"github.com/khalidibnwalid/sadaa/server/internal/graph"
	graph_models "github.com/khalidibnwalid/sadaa/server/internal/graph/models"
	"github.com/khalidibnwalid/sadaa/server/internal/middleware"
	"github.com/khalidibnwalid/sadaa/server/internal/models"
	"github.com/khalidibnwalid/sadaa/server/internal/services/auth"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input graph_models.SignupInput) (*db.User, error) {
	user := models.NewUser().
		WithPassword(input.Password)
	err := user.WithEmail(input.Email)
	if err != nil {
		return nil, gqlerror.Wrap(ErrInvalidEmailAddress)
	}

	//check if email is used
	if _, err = r.DB.GetUserByEmail(ctx, user.User.Email); err == nil {
		return nil, gqlerror.Wrap(ErrEmailExists)
	}

	// check if username is used
	user.Username = input.Username
	if _, err = r.DB.GetUserByUsername(ctx, user.Username); err == nil {
		return nil, gqlerror.Wrap(ErrUsernameExists)
	}

	usr, err := r.DB.CreateUser(ctx, db.CreateUserParams{
		Email:          user.User.Email,
		Username:       user.User.Username,
		HashedPassword: user.User.HashedPassword,
	})

	if err != nil {
		return nil, gqlerror.Wrap(ErrInternalServerError)
	}

	// write the cookie
	rw, ok := middleware.ForResponseWriter(ctx)
	if !ok {
		return nil, gqlerror.Wrap(ErrInternalServerError)
	}

	AuthCookie, err := auth.GenerateAuthCookie(&usr.ID, r.Auth.JWTSecret, !r.IsDevelopment)
	if err != nil {
		return nil, gqlerror.Wrap(ErrFailedToCreateAuthSession)
	}

	http.SetCookie(rw, AuthCookie)

	// Explicitly did this to ignore HashedPassword
	return &db.User{
		ID:        usr.ID,
		Email:     usr.Email,
		Username:  usr.Username,
		CreatedAt: usr.CreatedAt,
		UpdatedAt: usr.UpdatedAt,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input graph_models.LoginInput) (*db.User, error) {
	usr := models.NewUser()
	err := usr.WithEmail(input.Credential)

	// if Error parsing to mail, then its a username
	if err != nil {
		dbusr, err := r.DB.GetUserByUsername(ctx, input.Credential)
		if err != nil {
			return nil, gqlerror.Wrap(ErrUserNotFound)
		}
		usr = models.NewUser(dbusr)
	} else {
		dbusr, err := r.DB.GetUserByEmail(ctx, input.Credential)
		if err != nil {
			return nil, gqlerror.Wrap(ErrUserNotFound)
		}
		usr = models.NewUser(dbusr)
	}

	// Verify the password
	err = usr.VerifyPassword(input.Password)
	if err != nil {
		return nil, gqlerror.Wrap(ErrInvalidPassword)
	}

	// write the cookie
	rw, ok := middleware.ForResponseWriter(ctx)
	if !ok {
		return nil, gqlerror.Wrap(ErrInternalServerError)
	}

	AuthCookie, err := auth.GenerateAuthCookie(&usr.ID, r.Auth.JWTSecret, !r.IsDevelopment)
	if err != nil {
		return nil, gqlerror.Wrap(ErrFailedToCreateAuthSession)
	}

	http.SetCookie(rw, AuthCookie)

	// Explicitly did this to ignore HashedPassword
	return &db.User{
		ID:        usr.ID,
		Email:     usr.Email,
		Username:  usr.Username,
		CreatedAt: usr.CreatedAt,
		UpdatedAt: usr.UpdatedAt,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context) (*db.User, error) {
	userId, ok := auth.For(ctx)
	if !ok {
		return nil, gqlerror.Wrap(ErrUnauthorized)
	}

	usr, err := r.DB.GetUserByID(ctx, *userId)
	if err != nil {
		return nil, gqlerror.Wrap(ErrUserNotFound)
	}

	return usr, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	return &obj.CreatedAt.Time, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	return &obj.UpdatedAt.Time, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
